# Plan Detallado de Desarrollo: Sistema de Telemedicina Rural Colombia

## Enfoque T√©cnico Profundo para Arquitectos y Desarrolladores

---
## üìã Introducci√≥n

Este documento expande el plan de desarrollo original para el Sistema de Telemedicina Rural en Colombia. El objetivo es proporcionar una gu√≠a t√©cnica detallada, paso a paso, para cada tarea, asumiendo el rol de un arquitecto y desarrollador senior. Se definir√°n servicios, funciones, estructuras de datos, posibles endpoints y las interacciones clave entre componentes. La problem√°tica central es la conectividad intermitente y de bajo ancho de banda en zonas rurales, lo que hace que el mecanismo de "**Store-and-Forward**" y un protocolo de comunicaci√≥n adaptable sean cr√≠ticos.

---
## üéØ Objetivos del Proyecto (Recordatorio)
**Objetivo General**

Dise√±ar, implementar y evaluar un sistema de telemedicina basado en redes de comunicaci√≥n adaptativas, capaz de operar eficazmente sobre infraestructuras de red con conectividad intermitente o de bajo ancho de banda.

**Objetivos Espec√≠ficos**
- **Acceso a Servicios M√©dicos:** Facilitar el acceso a diagn√≥stico y consulta.
- **Reducci√≥n de Inequidad Sanitaria:** Disminuir la brecha campo-ciudad.
- **Validaci√≥n T√©cnica:** Prototipar y validar un mecanismo de comunicaci√≥n resiliente.

---
## üèóÔ∏è Arquitectura del Sistema (Recordatorio)
**Componentes Principales**
- **NAP (Nodo de Atenci√≥n Primaria):** Cliente ligero, captura y transmite datos.
- **CMR (Centro M√©dico Remoto):** Servidor central, recibe, procesa y almacena.
- **Protocolo Store-and-Forward (S&F):** Esencial para la resiliencia.
- **Simulador de Red Rural:** Para pruebas en condiciones adversas.

**Stack Tecnol√≥gico (Recordatorio)**
- **Lenguaje:** Python 3.11+
- **Framework Backend:** FastAPI
- **Base de Datos:** PostgreSQL (CMR), SQLite (NAP)
- **Networking:** AsyncIO, Sockets nativos, aiohttp
- **Simulaci√≥n:** Mininet, netem, Scapy
- **Contenedorizaci√≥n:** Docker, Docker Compose
- **Testing:** pytest, pytest-asyncio

---
## üìÖ Plan de Desarrollo Detallado

### Fase 0: Preparaci√≥n y Configuraci√≥n 
- **Objetivo:** Establecer una base s√≥lida de desarrollo y comprensi√≥n del contexto.
- **Actividades Principales y Detalles T√©cnicos:**
    - **An√°lisis del Contexto Rural Colombiano:**
        - **Qu√© hacer:** Investigar y documentar las condiciones de conectividad (tipos de conexi√≥n predominantes: satelital, radioenlaces, 3G/4G irregular), infraestructura el√©ctrica, y capacidades t√©cnicas del personal local.
        - **C√≥mo:**
            - Revisar estudios del MinTIC sobre brecha digital rural.
            - Analizar datos de operadores sobre cobertura y calidad de servicio en zonas objetivo.
            - Considerar el impacto del Decreto 0351/2025 (Plan Nacional de Salud Rural) en los requisitos del sistema.
        - **Entregable Espec√≠fico:** Documento de "**Caracterizaci√≥n de Infraestructura y Conectividad Rural Colombiana**" con perfiles de red tipo.
    - **Configuraci√≥n del Entorno de Desarrollo:**
        - **Qu√© hacer:** Preparar todas las herramientas y la estructura base del proyecto.
        - **C√≥mo:**
            - **Repositorio Git:**
                - **Estructura de directorios:**
                  ```
                  nap-client/
                  cmr-server/
                  shared/
                  simulation/
                  docs/
                  tests/
                  ```
                - **Estrategia de ramas:** Un enfoque simple con `main` como rama principal y ramas de funcionalidad (`feature/xxx`). Gitflow es excesivo para un solo desarrollador.
                - **Convenciones de commit:** Uso de Conventional Commits.
                - **Hooks de pre-commit:** **(Prioridad Alta)** Configurar con `pre-commit` para ejecutar linters y formateadores (Black, Flake8, isort) autom√°ticamente. Es tu primera l√≠nea de defensa para mantener la calidad del c√≥digo sin esfuerzo.
            - **Docker y Docker Compose:**
                - `Dockerfile` base para Python (considerar multi-stage builds para optimizar tama√±o).
                - `Dockerfile` para NAP (incluyendo dependencias de UI si es necesario y SQLite).
                - `Dockerfile` para CMR (incluyendo FastAPI, PostgreSQL client, Redis client).
                - `docker-compose.yml` para desarrollo local: servicios para NAP, CMR, PostgreSQL, Redis, y el simulador de red (Mininet).
                - Variables de entorno (`.env` files) para configuraci√≥n.
            - **Herramientas de Calidad y Testing:**
                - Configuraci√≥n de `pytest` y `pytest-asyncio`.
                - Integraci√≥n de `coverage.py` para reportes de cobertura.
            - **CI/CD B√°sico (Enfoque para un solo desarrollador):**
                - **Objetivo:** Un pipeline simple (e.g., GitHub Actions) que act√∫a como tu red de seguridad personal, no como una herramienta de coordinaci√≥n de equipo.
                - **Activaci√≥n:** Se activa en cada `push` a cualquier rama.
                - **Jobs Esenciales:**
                    1.  **Calidad de C√≥digo:** Ejecuci√≥n de linters y formateadores (Black, Flake8, isort) para asegurar consistencia.
                    2.  **Pruebas Unitarias:** Ejecuci√≥n de `pytest` para garantizar que los cambios no rompen funcionalidades existentes.
                - **Jobs Opcionales/Manuales:** La ejecuci√≥n de la simulaci√≥n de red completa ser√° un paso manual o bajo demanda, no en cada commit, para agilizar el ciclo de desarrollo.
        - **Entregable Espec√≠fico:** Repositorio Git funcional con estructura, Dockerfiles, `docker-compose.yml` y pipeline CI/CD b√°sico operativo.

---
### Fase 1: Desarrollo de Componentes Compartidos
- **Objetivo:** Implementar librer√≠as y protocolos base que ser√°n utilizados tanto por el NAP como por el CMR.
- **1. Infraestructura Base (`shared/`)**
    - **`shared/utils/logging_config.py`:**
        - **Qu√© hacer:** M√≥dulo para configurar un logging estructurado y centralizado.
        - **C√≥mo:**
            - Funci√≥n `setup_logging(service_name: str, log_level: str = "INFO", structured: bool = True) -> logging.Logger`.
            - Utilizar `python-json-logger` si se opta por logs estructurados en JSON para facilitar el an√°lisis por herramientas como ELK Stack o similar en un futuro.
            - Configurar handlers para consola y, opcionalmente, para archivos con rotaci√≥n.
    - **`shared/utils/config_loader.py`:**
        - **Qu√© hacer:** M√≥dulo para cargar configuraciones de manera flexible.
        - **C√≥mo:**
            - Clase `AppConfig` utilizando Pydantic para validaci√≥n y tipado.
            - Carga desde variables de entorno (prioridad alta) y archivos `.env` (prioridad baja).
            - Secciones de configuraci√≥n: `database_nap`, `database_cmr`, `network_nap`, `network_cmr`, `redis_config`.
    - **`shared/utils/network_utils.py`:**
        - **Qu√© hacer:** Utilidades de red comunes.
        - **C√≥mo:**
            - Funci√≥n `async def check_host_port_availability(host: str, port: int) -> bool`.
            - Funci√≥n `get_local_ip_address() -> str`.
            - Considerar funciones para estimar ancho de banda b√°sico o latencia si no se usa una librer√≠a m√°s compleja (e.g., ping simple).
    - **`shared/protocols/message_formats/`:**
        - **Qu√© hacer:** Definir las estructuras de los mensajes intercambiados.
        - **C√≥mo:** Usar Pydantic para definir modelos de datos.
            - **`medical_message.py`:**
                - `MedicalDataPayload(BaseModel)`: `message_id: UUID`, `patient_id: str`, `nap_id: str`, `timestamp_capture: datetime`, `priority: int` (e.g., 1-CRITICAL, 2-HIGH, 3-NORMAL), `data_type: str` (e.g., "ECG", "SpO2", "BloodPressure"), `data: Dict | List | bytes` (el contenido m√©dico real), `metadata: Optional[Dict]`.
                - **M√©todos:** `serialize_json() -> str`, `serialize_bytes() -> bytes` (usando `msgpack` o `protobuf` para eficiencia si es necesario), `static deserialize_json(data_str: str)`, `static deserialize_bytes(data_bytes: bytes)`.
            - **`control_message.py`:**
                - `AckMessage(BaseModel)`: `message_id_acked: UUID`, `status: str` ("RECEIVED", "PROCESSED"), `timestamp: datetime`.
                - `NackMessage(BaseModel)`: `message_id_nacked: UUID`, `reason: str`, `timestamp: datetime`.
                - `HeartbeatMessage(BaseModel)`: `nap_id: str`, `timestamp: datetime`, `status: str` ("ALIVE").
            - **`priority_message.py`:**
                - `MessagePriority(IntEnum)`: `CRITICAL = 1`, `HIGH = 2`, `NORMAL = 3`, `LOW = 4`.
                - Funciones de utilidad para asignar/interpretar prioridades.
    - **`shared/protocols/compression/medical_data_compressor.py`:**
        - **Qu√© hacer:** Implementar compresi√≥n/descompresi√≥n de datos m√©dicos.
        - **C√≥mo:**
            - Interfaz `AbstractCompressor(ABC)`: `compress(data: bytes) -> bytes`, `decompress(data: bytes) -> bytes`.
            - Implementaciones: `ZlibCompressor(AbstractCompressor)`, `LZMACompressor(AbstractCompressor)`.
            - Considerar una factor√≠a `CompressorFactory.get_compressor(algorithm_name: str = "zlib") -> AbstractCompressor`.
            - La elecci√≥n del algoritmo puede depender del tipo de dato m√©dico y el perfil de red.
- **2. Protocolo de Comunicaci√≥n Resiliente (`shared/protocols/reliable_udp/`)**
    - **Objetivo:** Implementar un protocolo sobre UDP que ofrezca garant√≠as de entrega.
    - **`packet.py`:**
        - **Qu√© hacer:** Definir la estructura del paquete UDP confiable.
        - **C√≥mo:**
            - `ReliableUDPPacketHeader(BaseModel)`: `seq_num: int`, `ack_num: int`, `flags: int` (combinaci√≥n de `SYN`, `ACK`, `FIN`, `DATA`, `KEEPALIVE`, `SACK_PERMITTED`, `SACK`), `window_size: int`, `checksum: int`.
            - `ReliableUDPPacket(BaseModel)`: `header: ReliableUDPPacketHeader`, `payload: Optional[bytes]`.
            - M√©todos de serializaci√≥n/deserializaci√≥n (e.g., a/desde bytes usando `struct` para el header y concatenando payload).
            - Funciones para calcular/validar checksum (e.g., Fletcher's checksum o CRC32).
    - **`sequence_manager.py`:**
        - **Qu√© hacer:** Gestionar n√∫meros de secuencia y ACK.
        - **C√≥mo:**
            - Clase `SequenceManager`: `current_send_seq`, `expected_ack_seq`, `expected_receive_seq`.
            - **M√©todos:** `get_next_send_seq() -> int`, `update_on_ack(ack_num: int)`, `is_expected_packet(seq_num: int) -> bool`.
    - **`acknowledgment.py`:**
        - **Qu√© hacer:** Manejar la l√≥gica de env√≠o y recepci√≥n de ACKs.
        - **C√≥mo:**
            - Clase `AckHandler`:
                - `generate_ack_packet(received_seq_num: int, current_window_size: int) -> ReliableUDPPacket`.
                - `process_incoming_ack(packet: ReliableUDPPacket, retransmission_manager: 'RetransmissionManager', window_manager: 'WindowManager')`.
                - Considerar SACK (Selective Acknowledgment) si el tiempo lo permite, para mejorar eficiencia en redes con p√©rdidas espor√°dicas.
    - **`retransmission_handler.py`:**
        - **Qu√© hacer:** Gestionar la retransmisi√≥n de paquetes perdidos.
        - **C√≥mo:**
            - Clase `RetransmissionManager`:
                - `sent_packets_buffer: Dict[int, Tuple[ReliableUDPPacket, float_timestamp, int_retry_count]]`.
                - `rto_calculator: RTOCalculator` (implementando RTT promedio, desviaci√≥n, y c√°lculo de RTO, e.g., Jacobson/Karels).
                - **M√©todos:** `on_packet_sent(packet: ReliableUDPPacket)`, `on_ack_received(ack_num: int)` (elimina de buffer), `get_packets_for_retransmission() -> List[ReliableUDPPacket]` (verifica timeouts).
                - Implementar un temporizador por paquete o un temporizador global que revise el buffer.
    - **`window_manager.py`:**
        - **Qu√© hacer:** Implementar control de flujo mediante ventana deslizante.
        - **C√≥mo:**
            - Clase `SlidingWindowManager`:
                - `send_window_size`, `receive_window_size`, `last_byte_sent`, `last_byte_acked`, `congestion_control_algorithm` (e.g., AIMD - Additive Increase Multiplicative Decrease).
                - **M√©todos:** `can_send_more_data(data_size: int) -> bool`, `update_window_on_ack(ack_num: int)`, `update_window_on_loss()`, `get_advertised_window() -> int`.
    - **`reliable_udp_socket.py` (Opcional, encapsulador):**
        - **Qu√© hacer:** Una clase que una todos los componentes anteriores para ofrecer una API similar a un socket.
        - **C√≥mo:**
            - Clase `ReliableUDPSocket(host, port, is_server=False)`:
                - `async def connect()` (para cliente, maneja handshake SYN/SYN-ACK).
                - `async def listen()` (para servidor).
                - `async def send(data: bytes) -> bool`.
                - `async def recv() -> bytes`.
                - `async def close()` (maneja FIN/FIN-ACK).
                - Internamente usa `asyncio.DatagramProtocol`.
- **3. M√≥dulo de Condiciones Rurales Colombianas (`shared/rural_conditions/`)**
    - **Qu√© hacer:** Definir perfiles y datos para la simulaci√≥n.
    - **C√≥mo:**
        - **`connectivity_profiles.py`:**
            - Lista de `RuralProfile(BaseModel)`: `name: str`, `avg_bandwidth_kbps: float`, `min_bandwidth_kbps: float`, `max_bandwidth_kbps: float`, `avg_latency_ms: int`, `jitter_ms: int`, `packet_loss_percentage: float`, `intermittency: Optional[IntermittencyProfile]`.
            - `IntermittencyProfile(BaseModel)`: `type: str` ("periodic", "random"), `down_duration_avg_s: int`, `up_duration_avg_s: int`.
        - Estos perfiles ser√°n usados por el simulador de red.
- **Entregables Fase 1:** Librer√≠as compartidas funcionales y probadas unitariamente. Protocolo UDP confiable con implementaci√≥n base de secuencia, ACK, retransmisi√≥n y ventana.

---
### Fase 2: Desarrollo del Cliente NAP
- **Objetivo:** Implementar el Nodo de Atenci√≥n Primaria con l√≥gica de Store-and-Forward y transmisi√≥n adaptativa.
- **1. Core del Cliente (`nap-client/src/`) (Semana 4)**
    - **`domain/entities/`:**
        - `MedicalDataRecord(BaseModel)`: `id: UUID` (generado en NAP), `patient_id: str`, `capture_timestamp: datetime`, `data_type: str`, `raw_data_payload: bytes` (datos m√©dicos serializados y posiblemente pre-comprimidos), `priority: MessagePriority`, `status: str` ("PENDING_QUEUE", "QUEUED", "SENDING", "SENT_UNCONFIRMED", "CONFIRMED_DELIVERY", "FAILED_MAX_RETRIES"), `creation_timestamp: datetime`, `last_attempt_timestamp: Optional[datetime]`, `retry_count: int = 0`.
    - **`domain/repositories/`:**
        - `AbstractMedicalDataRepository(ABC)`:
            - `async def save(record: MedicalDataRecord)`.
            - `async def get_by_id(id: UUID) -> Optional[MedicalDataRecord]`.
            - `async def get_pending_records(limit: int = 10) -> List[MedicalDataRecord]` (ordenados por prioridad y antig√ºedad).
            - `async def update_status(id: UUID, status: str, last_attempt_timestamp: Optional[datetime] = None, increment_retry: bool = False)`.
            - `async def delete(id: UUID)`.
        - `AbstractTransmissionQueueRepository(ABC)`: (Podr√≠a ser el mismo que `MedicalDataRepository` si la "cola" es solo una vista de los registros con estado "QUEUED"). Si es una cola separada (e.g., en memoria con persistencia):
            - `async def enqueue(record_id: UUID, priority: MessagePriority)`.
            - `async def dequeue() -> Optional[UUID]`.
            - `async def peek() -> Optional[UUID]`.
            - `async def get_all_ids_by_priority() -> List[UUID]`.
    - **`application/use_cases/`:**
        - `CaptureMedicalDataUseCase(data_repo: AbstractMedicalDataRepository)`:
            - `async def execute(patient_id: str, data_type: str, raw_data: Any, priority: MessagePriority) -> MedicalDataRecord`: Crea `MedicalDataRecord`, lo guarda con estado `PENDING_QUEUE` o `QUEUED` directamente.
        - `ProcessTransmissionQueueUseCase(data_repo: AbstractMedicalDataRepository, transmission_service: 'AdaptiveTransmissionService')`:
            - `async def execute_once()`: Obtiene el siguiente `MedicalDataRecord` de alta prioridad de `data_repo` (estado `QUEUED` o `FAILED_MAX_RETRIES` < umbral). Intenta enviarlo usando `transmission_service`. Actualiza estado.
            - Esta es la funci√≥n que se ejecutar√° peri√≥dicamente o en un bucle.
    - **`application/services/`:**
        - `StoreAndForwardService(data_repo: AbstractMedicalDataRepository, transmission_service: 'AdaptiveTransmissionService', config: AppConfig)`:
            - `task_process_queue: Optional[asyncio.Task] = None`.
            - `async def start_processing()`: Inicia un bucle `asyncio` que llama a `ProcessTransmissionQueueUseCase.execute_once()` a intervalos configurables (e.g., cada X segundos) o cuando hay conectividad.
            - `async def stop_processing()`: Cancela la tarea.
            - `async def force_process_item(record_id: UUID)`: Intenta enviar un √≠tem espec√≠fico.
        - `PriorityManagerService`: (Puede ser impl√≠cito en las consultas al `MedicalDataRepository` si se ordena por prioridad).
        - `AdaptiveTransmissionService(network_monitor: 'NetworkMonitor', protocol_selector: 'AdaptiveProtocolSelector', tcp_adapter: 'TCPAdapter', reliable_udp_adapter: 'ReliableUDPAdapter', compressor: AbstractCompressor, data_repo: AbstractMedicalDataRepository)`:
            - `async def send_medical_data(record: MedicalDataRecord) -> bool` (√©xito de env√≠o y confirmaci√≥n):
                - Obtiene `record.raw_data_payload`.
                - Comprime los datos: `compressed_payload = compressor.compress(record.raw_data_payload)`.
                - Crea el `MedicalDataPayload` (de shared) con `compressed_payload`.
                - Serializa: `message_bytes = medical_payload.serialize_bytes()`.
                - Monitorea red: `current_conditions = await network_monitor.get_current_conditions()`.
                - Selecciona protocolo: `protocol_type = protocol_selector.select_protocol(current_conditions, record.priority)`.
                - Actualiza `record` a `SENDING` en `data_repo`.
                - Si `protocol_type == "TCP"`: `success = await tcp_adapter.send_and_await_ack(message_bytes, medical_payload.message_id)`.
                - Si `protocol_type == "RUDP"`: `success = await reliable_udp_adapter.send_and_await_ack(message_bytes, medical_payload.message_id)`.
                - Si `success`: Actualiza `record` a `CONFIRMED_DELIVERY`. Sino, `FAILED_MAX_RETRIES` (o similar) y se reintentar√°.
                - Retorna `success`.
- **2. Infraestructura y Adaptadores (`nap-client/src/infrastructure/`)**
    - **`network/tcp_adapter.py`:**
        - Clase `TCPAdapter(host: str, port: int, config: AppConfig)`:
            - `async def connect()`: Establece conexi√≥n TCP.
            - `async def send_data(data: bytes) -> bool`: Env√≠a datos.
            - `async def receive_ack(expected_message_id: UUID, timeout: float) -> bool`: Espera un `AckMessage`.
            - `async def send_and_await_ack(data: bytes, message_id: UUID) -> bool`: Combina env√≠o y espera de ACK.
            - `async def disconnect()`.
            - Usa `asyncio.open_connection`.
    - **`network/reliable_udp_adapter.py`:**
        - Clase `ReliableUDPAdapter(host: str, port: int, config: AppConfig)`:
            - Internamente usa una instancia de `ReliableUDPSocket` (o su l√≥gica).
            - `async def send_data(data: bytes) -> bool`: Env√≠a usando el protocolo RUDP.
            - `async def await_ack(expected_message_id: UUID, timeout: float) -> bool`: Espera confirmaci√≥n a nivel de aplicaci√≥n (que el RUDP haya confirmado la entrega del paquete que conten√≠a el ACK del CMR).
            - `async def send_and_await_ack(data: bytes, message_id: UUID) -> bool`.
    - **`network/network_monitor.py`:**
        - Clase `NetworkMonitor(config: AppConfig)`:
            - `current_status: NetworkStatus(BaseModel)` con `connected: bool`, `latency_ms: Optional[float]`, `packet_loss_estimate: Optional[float]`, `bandwidth_kbps_estimate: Optional[float]`.
            - `async def get_current_conditions() -> NetworkStatus`:
                - Intenta un ping simple (ICMP o TCP echo a un host conocido/CMR).
                - Mide tiempo de conexi√≥n/respuesta.
                - Puede usar `pythonping` o `async_ping`.
                - Mantiene un estado interno que se actualiza peri√≥dicamente.
            - `async def start_monitoring()`, `async def stop_monitoring()`.
    - **`network/adaptive_protocol_selector.py`:**
        - Clase `AdaptiveProtocolSelector(config: AppConfig)`:
            - `def select_protocol(network_status: NetworkStatus, priority: MessagePriority) -> str` ("TCP" | "RUDP"):
                - **L√≥gica:**
                    - Si `not network_status.connected`: Error, no se puede enviar.
                    - Si `network_status.packet_loss_estimate > config.rudp_loss_threshold` o `network_status.latency_ms > config.rudp_latency_threshold`: Usar "RUDP".
                    - Si `priority == MessagePriority.CRITICAL` y red inestable: Usar "RUDP".
                    - Por defecto: "TCP" (si es m√°s simple o configurado as√≠).
    - **`persistence/sqlite_repository.py`:**
        - Clase `SQLiteMedicalDataRepository(AbstractMedicalDataRepository)`:
            - Usa `aiosqlite`.
            - `db_path: str`.
            - M√©todo `async def _init_db()`: Crea tablas (`medical_records`) si no existen.
            - **Campos en tabla `medical_records`**: `id TEXT PRIMARY KEY`, `patient_id TEXT`, `capture_timestamp TEXT`, `data_type TEXT`, `raw_data_payload BLOB`, `priority INTEGER`, `status TEXT`, `creation_timestamp TEXT`, `last_attempt_timestamp TEXT`, `retry_count INTEGER`.
            - Implementa todos los m√©todos de la interfaz.
    - **`persistence/file_storage.py` (Opcional, si hay archivos grandes):**
        - Clase `LocalFileStorage`:
            - `async def save_large_data(record_id: UUID, data: bytes) -> str` (ruta_archivo).
            - `async def load_large_data(file_path: str) -> bytes`.
            - La `MedicalDataRecord.raw_data_payload` almacenar√≠a la ruta al archivo en este caso.
    - **`ui/cli_interface.py`:**
        - Usa `typer` o `click` para una CLI amigable.
        - **Comandos:**
            - `nap-client capture --patient-id <id> --type <ECG|SpO2> --priority <1-4> --data-file <ruta_o_direct_input>`
            - `nap-client queue status`
            - `nap-client queue process [--force]`
            - `nap-client network status`
            - `nap-client config show`
    - **`ui/medical_data_simulator.py` (Para pruebas):**
        - Funciones para generar datos m√©dicos simulados: `generate_ecg_sample(duration_s, sample_rate_hz) -> List[float]`, `generate_spo2_sample() -> int`.
        - Puede ser invocado por la CLI para generar archivos de datos.
- **Entregables Fase 2:** Cliente NAP funcional con Store-and-Forward, priorizaci√≥n b√°sica, capacidad de transmisi√≥n adaptativa (selector de protocolo base), persistencia en SQLite y una CLI para interacci√≥n y pruebas.

---
### Fase 3: Desarrollo del Servidor CMR
- **Objetivo:** Implementar el Centro M√©dico Remoto para recibir, procesar y almacenar datos.
- **1. Core del Servidor (`cmr-server/src/`)**
    - **`domain/entities/`:**
        - `ReceivedMedicalData(BaseModel)`: Similar a `MedicalDataPayload` de `shared`, pero con metadatos del servidor como `received_timestamp: datetime`, `source_nap_id: str`.
        - `MedicalRecordEntry(BaseModel)`: `entry_id: UUID`, `nap_message_id: UUID`, `patient_id: str`, `received_timestamp: datetime`, `capture_timestamp: datetime`, `data_type: str`, `processed_data: Dict | List` (datos decodificados y validados), `priority: MessagePriority`.
        - `PatientMedicalRecord(BaseModel)`: `patient_id: str`, `entries: List[MedicalRecordEntry]`, `diagnoses: List[Diagnosis]`.
        - `Diagnosis(BaseModel)`: `diagnosis_id: UUID`, `specialist_id: str`, `timestamp: datetime`, `notes: str`.
    - **`domain/repositories/`:**
        - `AbstractMedicalRecordRepository(ABC)`:
            - `async def add_medical_data_entry(entry: MedicalRecordEntry)`.
            - `async def get_record_for_patient(patient_id: str) -> Optional[PatientMedicalRecord]`.
            - `async def add_diagnosis_to_patient(patient_id: str, diagnosis: Diagnosis)`.
    - **`application/use_cases/`:**
        - `ReceiveMedicalDataUseCase(record_repo: AbstractMedicalRecordRepository, validation_service: 'DataValidationService', notification_service: 'NotificationService', compressor: AbstractCompressor)`:
            - `async def execute(raw_message_bytes: bytes, source_nap_id: str) -> Tuple[bool, Optional[str]]` (success, error_message):
                - Deserializa `raw_message_bytes` a `MedicalDataPayload` (de `shared`).
                - Valida con `validation_service`. Si falla, retorna (`False`, "Validation Error").
                - Descomprime `medical_payload.data` usando `compressor`.
                - Crea `MedicalRecordEntry`.
                - Guarda en `record_repo`.
                - Si `entry.priority == MessagePriority.CRITICAL`, llama a `notification_service.notify_critical_data_received(entry)`.
                - Retorna (`True`, `None`).
        - `ProcessDiagnosisRequestUseCase(record_repo: AbstractMedicalRecordRepository)`: (Simplificado para este scope)
            - `async def add_diagnosis(patient_id: str, specialist_id: str, notes: str) -> Diagnosis`.
        - `GeneratePriorityAlertsUseCase(notification_service: 'NotificationService')`:
            - Esta l√≥gica est√° m√°s integrada en `ReceiveMedicalDataUseCase` para alertas inmediatas. Podr√≠a haber un servicio batch que revise datos no atendidos.
    - **`application/services/`:**
        - `DataValidationService()`:
            - `def validate_medical_payload(payload: MedicalDataPayload) -> List[str]` (lista de errores): Verifica campos requeridos, tipos, rangos l√≥gicos para ciertos `data_type`.
        - `NotificationService(config: AppConfig, notification_gateways: List[AbstractNotificationGateway])`:
            - `async def notify_critical_data_received(entry: MedicalRecordEntry)`: Env√≠a notificaciones (e.g., email, SMS, WebSocket) a personal relevante.
            - `async def send_general_alert(message: str, target_group: str)`.
        - `AnalyticsService(record_repo: AbstractMedicalRecordRepository)`:
            - `async def get_reception_stats_last_hour() -> Dict`.
            - `async def get_patient_data_summary(patient_id: str) -> Dict`.
- **2. API y Comunicaciones (`cmr-server/src/infrastructure/`)**
    - **`network/socket_servers.py`:**
        - **`tcp_server.py`:**
            - Funci√≥n `async def handle_tcp_client(reader: asyncio.StreamReader, writer: asyncio.StreamWriter, receive_use_case: ReceiveMedicalDataUseCase)`:
                - Lee datos del `reader`.
                - Pasa a `receive_use_case.execute()`.
                - Crea `AckMessage` o `NackMessage` (de `shared`).
                - Env√≠a respuesta por `writer`.
            - Funci√≥n `async def start_tcp_server(host: str, port: int, receive_use_case: ReceiveMedicalDataUseCase)`: Usa `asyncio.start_server`.
            - **Endpoint L√≥gico:** `tcp://<CMR_IP>:<TCP_PORT>`
        - **`reliable_udp_server.py`:**
            - Clase `CMRReliableUDPProtocol(asyncio.DatagramProtocol)`:
                - Usa la instancia de `ReliableUDPSocket` o su l√≥gica interna.
                - En `datagram_received`, procesa el paquete RUDP. Si es un paquete de DATOS completo:
                    - Pasa a `receive_use_case.execute()`.
                    - Prepara `AckMessage` o `NackMessage` como payload para la respuesta RUDP.
            - Funci√≥n `async def start_reliable_udp_server(host: str, port: int, receive_use_case: ReceiveMedicalDataUseCase)`: Crea y configura el endpoint de datagrama.
            - **Endpoint L√≥gico:** `rudp://<CMR_IP>:<RUDP_PORT>`
    - **`network/api_server.py` (FastAPI):**
        - Archivo principal de FastAPI (`main.py`).
        - Routers separados: `patients_router.py`, `diagnostics_router.py`, `analytics_router.py`.
        - Inyecci√≥n de dependencias (Use Cases, Repositories) usando `fastapi.Depends`.
        - **Endpoints REST (Ejemplos):**
            - `POST /api/v1/medical_data/upload_http`: (Alternativa HTTP para NAPs, menos resiliente pero m√°s simple si la red lo permite). Recibe `MedicalDataPayload`. Llama a `ReceiveMedicalDataUseCase`.
                - **Request Body:** `MedicalDataPayload` (JSON).
                - **Response:** 200 OK con `AckMessage` o 400/500 con `NackMessage`.
            - `GET /api/v1/patients/{patient_id}/records`: Retorna `PatientMedicalRecord`. Requiere autenticaci√≥n/autorizaci√≥n.
            - `POST /api/v1/patients/{patient_id}/diagnoses`: Recibe datos de diagn√≥stico. Llama a `ProcessDiagnosisRequestUseCase.add_diagnosis`.
                - **Request Body:** `{"specialist_id": "...", "notes": "..."}`.
                - **Response:** 201 Created con `Diagnosis`.
            - `GET /api/v1/system/health`: Endpoint de health check.
        - **Autenticaci√≥n:** Implementar OAuth2 con JWT para proteger los endpoints de la API que exponen datos sensibles.
    - **`network/websocket_server.py`:**
        - Integrado con FastAPI.
        - `async def websocket_endpoint_alerts(websocket: WebSocket, token: str = Depends(oauth2_scheme))`:
            - Autentica el WebSocket.
            - Mantiene la conexi√≥n y env√≠a mensajes cuando `NotificationService` emite una alerta para el grupo/usuario relevante.
        - **Endpoint L√≥gico:** `ws://<CMR_IP>:<API_PORT>/ws/alerts`
    - **`persistence/postgresql_adapter.py`:**
        - Clase `PostgresMedicalRecordRepository(AbstractMedicalRecordRepository)`:
            - Usa `asyncpg` directamente o con SQLAlchemy Async (recomendado).
            - **Tablas:**
                - `patients` (`patient_id TEXT PRIMARY KEY`, `name TEXT`, ...)
                - `medical_record_entries` (`entry_id UUID PRIMARY KEY`, `nap_message_id UUID`, `patient_id TEXT REFERENCES patients`, `received_timestamp TIMESTAMPTZ`, `capture_timestamp TIMESTAMPTZ`, `data_type TEXT`, `processed_data JSONB`, `priority INTEGER`)
                - `diagnoses` (`diagnosis_id UUID PRIMARY KEY`, `patient_id TEXT REFERENCES patients`, `specialist_id TEXT`, `timestamp TIMESTAMPTZ`, `notes TEXT`)
            - Implementa todos los m√©todos de la interfaz.
    - **`persistence/redis_cache.py`:**
        - Clase `RedisCacheService`:
            - Usa `redis-py` (con soporte `async`).
            - `async def get_value(key: str) -> Optional[str]`.
            - `async def set_value(key: str, value: str, ttl_seconds: int)`.
            - Para caching de sesiones de API, resultados de queries frecuentes, etc.
    - **`external/notification_gateways.py`:**
        - `AbstractNotificationGateway(ABC)`: `async def send(recipient: str, message: str, subject: Optional[str]=None)`.
        - `EmailGateway(AbstractNotificationGateway)`: Usa `smtplib` o una librer√≠a como `emails`.
        - `SmsGateway(AbstractNotificationGateway)`: (Mock o integraci√≥n con Twilio/Vonage si hay presupuesto).
        - `WebSocketGateway(AbstractNotificationGateway)`: Interact√∫a con el `websocket_server.py` para empujar notificaciones a clientes conectados.
- **Entregables Fase 3:** Servidor CMR funcional con endpoints TCP y RUDP para recepci√≥n de datos, API REST b√°sica para gesti√≥n y consulta, y sistema de notificaciones/alertas inicial. Persistencia en PostgreSQL.

---
### Fase 4: Simulaci√≥n y Pruebas Integrales
- **Objetivo:** Validar el sistema completo bajo condiciones de red rural simuladas.
- **1. Entorno de Simulaci√≥n (`simulation/`)**
    - **`network_simulator/rural_colombia_topology.py`:**
        - **Qu√© hacer:** Script Python que usa la API de Mininet para crear topolog√≠as de red.
        - **C√≥mo:**
            - Funci√≥n `create_rural_topology(profile_name: str, rural_profiles: List[RuralProfile]) -> Mininet`.
            - Define Nodos: `NAP1 = net.addHost('nap1')`, `CMR = net.addHost('cmr')`, `Switch = net.addSwitch('s1')`.
            - Define Enlaces: `net.addLink(NAP1, Switch, bw=profile.avg_bandwidth_kbps/1000, delay=f'{profile.avg_latency_ms}ms', loss=profile.packet_loss_percentage)`.
            - Permite parametrizar la topolog√≠a (N NAPs, 1 CMR).
    - **`network_simulator/connectivity_patterns.py`:**
        - **Qu√© hacer:** Scripts para aplicar din√°micamente cambios en las condiciones de red.
        - **C√≥mo:**
            - Funci√≥n `apply_intermittency(net: Mininet, link_node1: str, link_node2: str, profile: IntermittencyProfile)`:
                - Usa `tc` (a trav√©s de `link.config()` en Mininet) para simular la ca√≠da y restauraci√≥n del enlace peri√≥dicamente o aleatoriamente.
                - Ejemplo: `link.config(loss=100)` para simular ca√≠da, `link.config(loss=original_loss)` para restaurar.
            - Funci√≥n `change_bandwidth_latency(net: Mininet, link_node1: str, link_node2: str, new_bw_kbps: float, new_latency_ms: int)`.
    - **`scenarios/`:**
        - **Qu√© hacer:** Scripts que orquestan una simulaci√≥n completa para un escenario dado.
        - **C√≥mo:**
            - **`run_amazon_region_scenario.py`:**
                - Carga el perfil "Amazonas" de `connectivity_profiles.py`.
                - Crea la topolog√≠a con `rural_colombia_topology.py`.
                - Inicia los contenedores Docker del NAP y CMR dentro de los nodos de Mininet (usando `host.cmd('docker run ...')`).
                - Inicia el `medical_data_simulator.py` en el NAP para generar y enviar datos.
                - Aplica patrones de intermitencia y cambios de ancho de banda con `connectivity_patterns.py`.
                - Ejecuta durante un tiempo definido, recolectando logs.
                - Detiene los contenedores y la red.
            - Otros escenarios: `andes_mountain_scenario.py`, `emergency_scenario.py` (con alta prioridad de datos).
- **2. Evaluaci√≥n de Rendimiento (`simulation/`)**
    - **`metrics/performance_collector.py`:**
        - **Qu√© hacer:** Scripts o modificaciones en NAP/CMR para registrar m√©tricas detalladas.
        - **C√≥mo:**
            - **NAP:** Loguear (`message_id`, `capture_time`, `queue_time`, `send_attempt_time`, `protocol_used`, `ack_receive_time`, `final_status`, `num_retries`).
            - **CMR:** Loguear (`message_id`, `receive_time`, `processing_complete_time`, `nap_source_id`).
            - Estos logs deben ser f√°cilmente parseables (e.g., CSV o JSON por l√≠nea).
    - **`metrics/analyzers/`:**
        - Scripts Python para procesar los logs de `performance_collector` y los logs de aplicaci√≥n.
        - **`reliability_analyzer.py`:** Calcula Tasa de Entrega Exitosa ((mensajes_confirmados_NAP / mensajes_enviados_NAP) * 100 o (mensajes_recibidos_CMR / mensajes_enviados_NAP) * 100).
        - **`latency_analyzer.py`:** Calcula Latencia End-to-End (`ack_receive_time` - `capture_time`). Distribuci√≥n de latencias.
        - **`throughput_analyzer.py`:** Calcula Throughput Efectivo (total_datos_utiles_recibidos_CMR / tiempo_simulacion).
        - **`s_and_f_analyzer.py`:** Analiza el comportamiento de la cola en el NAP (tama√±o m√°x/promedio, tiempo en cola).
    - **`reports/performance_reporter.py`:**
        - **Qu√© hacer:** Generar reportes visuales y tabulares.
        - **C√≥mo:**
            - Usar `pandas` para manipulaci√≥n de datos, `matplotlib/seaborn` para gr√°ficos (histogramas de latencia, series temporales de throughput, etc.).
            - Generar un informe Markdown o HTML (usando Jinja2) comparando TCP vs RUDP bajo diferentes escenarios.
- **Pruebas Sistem√°ticas (Detalle):**
    - **L√≠nea Base:** Red ideal (alta BW, baja latencia, 0 p√©rdida).
    - **Variaci√≥n de Ancho de Banda:** Escalonado desde 56 Kbps hasta 2 Mbps.
    - **Variaci√≥n de Latencia:** Desde 100ms hasta 2000ms.
    - **Variaci√≥n de P√©rdida de Paquetes:** Desde 0% hasta 25%.
    - **Simulaci√≥n de Intermitencia:**
        - Cortes cortos y frecuentes (e.g., 10s abajo, 60s arriba).
        - Cortes largos y espor√°dicos (e.g., 5min abajo, 30min arriba).
    - **Combinaciones:** Escenarios realistas combinando varios factores (e.g., baja BW + alta latencia + p√©rdida moderada).
    - **Pruebas de Carga:** M√∫ltiples NAPs enviando datos concurrentemente.
    - **Pruebas de Prioridad:** Verificar que los datos cr√≠ticos se procesan y transmiten antes.
- **Entregables Fase 4:** Entorno de simulaci√≥n funcional, scripts para ejecutar escenarios, scripts de an√°lisis de m√©tricas y un informe preliminar de rendimiento comparativo.

---
### Fase 5: An√°lisis de Resultados y Documentaci√≥n Final
- **Objetivo:** Consolidar hallazgos, generar documentaci√≥n completa y recomendaciones.
- **1. An√°lisis de Resultados (Profundizaci√≥n)**
    - **Comparaci√≥n TCP vs. UDP Confiable (RUDP):**
        - **M√©tricas Clave:** Tasa de entrega, latencia E2E, throughput efectivo, sobrecarga de protocolo (bytes de control / bytes de datos), tiempo de recuperaci√≥n tras interrupci√≥n.
        - **An√°lisis:** ¬øEn qu√© umbrales de p√©rdida/latencia/intermitencia RUDP supera a TCP? ¬øCu√°l es el costo en t√©rminos de complejidad y sobrecarga? ¬øC√≥mo se comporta el control de congesti√≥n de RUDP (si se implement√≥ uno sofisticado) vs el de TCP?
    - **Validaci√≥n del Store-and-Forward (S&F):**
        - **M√©tricas Clave:** Tiempo promedio en cola (NAP), tama√±o m√°ximo de cola, tasa de descarte por llenado de cola (si aplica), impacto de la priorizaci√≥n en el tiempo de entrega de datos cr√≠ticos.
        - **An√°lisis:** ¬øEs la capacidad de almacenamiento del NAP (SQLite) suficiente para los escenarios de intermitencia prolongada? ¬øQu√© tan efectiva es la l√≥gica de reintento y backoff?
    - **Impacto de la Compresi√≥n:**
        - **M√©tricas Clave:** Ratio de compresi√≥n por tipo de dato, reducci√≥n en el tiempo de transmisi√≥n.
        - **An√°lisis:** ¬øEl overhead de CPU para comprimir/descomprimir es aceptable en dispositivos NAP de bajos recursos?
- **2. Documentaci√≥n Final (`docs/`)**
    - **`README.md`:** Gu√≠a de inicio r√°pido, c√≥mo clonar, configurar entorno, ejecutar pruebas b√°sicas.
    - **`architecture.md`:**
        - Diagramas de arquitectura (C4 si es posible: Contexto, Contenedores, Componentes).
        - Descripci√≥n detallada de NAP, CMR, `shared_libs`.
        - Flujo de datos para escenarios clave.
        - Decisiones de dise√±o y justificaciones.
    - **`deployment_guide.md`:**
        - C√≥mo desplegar NAP y CMR usando Docker.
        - Configuraciones de ejemplo para producci√≥n (variables de entorno, gesti√≥n de secretos).
        - Requisitos de infraestructura.
    - **`protocol_specification.md`:**
        - Detalles del formato de `MedicalDataPayload`, `ControlMessage`.
        - Especificaci√≥n del `ReliableUDPPacket` (campos, flags, handshake, cierre).
        - L√≥gica del Store-and-Forward.
    - **`simulation_environment.md`:**
        - C√≥mo usar el simulador de Mininet.
        - C√≥mo definir nuevos escenarios y perfiles de red.
    - **`performance_analysis.md`:** Informe final de rendimiento con todos los gr√°ficos, tablas y an√°lisis detallados.
    - **`api_reference.md`:** Documentaci√≥n de la API REST del CMR (generada con Swagger/OpenAPI desde FastAPI).
    - **`developer_guide.md`:** C√≥mo contribuir al c√≥digo, est√°ndares de codificaci√≥n, c√≥mo ejecutar tests.
    - **`regulatory_compliance.md`:**
        - An√°lisis de Ley Estatutaria 1751 de 2015 (derecho a la salud).
        - Ley 1419 de 2010 y Resoluci√≥n 2654 de 2019 (telesalud y telemedicina).
        - Ley 1581 de 2012 (protecci√≥n de datos personales - Habeas Data): Implicaciones para el cifrado, anonimizaci√≥n, consentimiento informado, almacenamiento seguro.
        - Considerar est√°ndares como HL7 FHIR para interoperabilidad futura.
    - **`future_work.md`:** Mejoras, optimizaciones, nuevas funcionalidades (e.g., IA para pre-diagn√≥stico, integraci√≥n HIS completa, app m√≥vil para NAP).
- **Entregables Fase 5:** Documentaci√≥n t√©cnica completa y exhaustiva, an√°lisis final de rendimiento y recomendaciones para futuras implementaciones o mejoras. C√≥digo fuente finalizado y probado.

